#N canvas 466 79 562 601 10;
#X obj 4 352 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 443 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 495 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 123 450 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 573 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 123 359 cnv 17 3 79 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 2 cnv 15 301 42 empty empty midi.learn 20 20 2 37 #e0e0e0 #000000 0;
#X obj 307 3 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 3 2 graph;
#X obj 346 10 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 22 39 cnv 4 4 4 empty empty MIDI 0 28 2 18 #e0e0e0 #000000 0;
#X obj 459 10 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 479 10 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 516 10 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 465 25 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 503 25 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 306 2 graph;
#X obj 72 39 cnv 4 4 4 empty empty learn 0 28 2 18 #e0e0e0 #000000 0;
#X obj 4 544 cnv 3 550 3 empty empty click 8 12 0 13 #dcdcdc #000000 0;
#X text 148 279 click to learn =>, f 8;
#X obj 213 208 bng 18 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 186 451 list -;
#X text 196 376 query;
#X msg 237 262 query;
#X obj 317 284 else/display;
#X msg 228 237 forget;
#X text 232 391 - forget input, f 47;
#X obj 123 472 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 190 391 forget;
#X text 161 473 anything -;
#X text 232 376 - print send stored input on right outlet, f 47;
#X text 202 360 bang -;
#N canvas 802 176 548 367 send-name 0;
#X text 56 238 click to learn =>, f 8;
#X obj 116 105 bng 18 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 140 105 <= click to learn, f 18;
#X msg 169 215 query;
#X obj 251 289 else/display;
#X msg 161 192 forget;
#X listbox 404 236 9 0 0 0 - - - 16;
#X listbox 404 277 9 0 0 0 - \$0-name - 16;
#X obj 404 212 r \$0-name;
#X obj 116 248 else/midi.learn \$0-name;
#A saved;
#X msg 135 138 set \\\$0-name-2;
#X listbox 404 154 9 0 0 0 - - - 16;
#X obj 404 130 r \$0-name-2;
#X text 232 146 set send name;
#X msg 146 161 set \\\$0-name;
#X text 83 37 A symbol argument (as the first or second argument) sets a send name. You can also set or change it with the 'set' message., f 41;
#X connect 1 0 9 0;
#X connect 3 0 9 0;
#X connect 5 0 9 0;
#X connect 8 0 6 0;
#X connect 9 1 4 0;
#X connect 10 0 9 0;
#X connect 12 0 11 0;
#X connect 14 0 9 0;
#X restore 457 319 pd send-name;
#X obj 206 290 else/midi.learn;
#A saved;
#A saved ctlin 19 3;
#X text 154 422 set <symbol> - set send name, f 60;
#X text 232 473 learned controller, f 47;
#X text 244 360 activate MIDI learn, f 45;
#X text 120 552 clicking on the object activates MIDI learn (same as bang);
#X text 62 81 [midi.learn] is an abstraction based on [savestate] that learns and saves any MIDI input data. Activate it via bang or click and send it MIDI data so it learns where it comes from. The information gets stored in the owning patch., f 73;
#X text 62 129 The Learned control/program change are followed by numbers that specify 'control/program number' and 'channel' or just a 'channel number' for note and bend messages (touch and polytouch are not supported)., f 73;
#X text 232 451 MIDI from learned input, f 47;
#X obj 209 319 hsl 150 18 0 127 0 0 empty empty empty -2 -8 0 10 #dfdfdf #000000 #000000 0 1;
#X text 100 211 click to learn =>;
#X msg 206 185 teach ctlin 19 3;
#X text 313 185 teach a specific MIDI message;
#X text 232 407 - teach a specific MIDI message, f 47;
#X text 130 407 teach <anything>;
#X text 149 523 2) symbol - send name (default none);
#X text 155 506 1) float - (optional) non-zero sets to abstraction mode;
#N canvas 703 168 440 306 abstraction-mode 0;
#X obj 71 137 bng 18 250 50 0 empty empty empty 17 7 0 10 #dfdfdf #000000 #000000;
#X text 95 137 <= click to learn, f 8;
#X obj 193 133 savestate;
#X obj 244 180 list;
#X obj 193 238 else/insert teach;
#X obj 71 173 else/midi.learn 1;
#A saved;
#X obj 265 155 list prepend param1;
#X obj 193 209 else/route2 param1;
#X text 68 32 An optional non zero argument sets the object to "abstraction" mode \, which is needed if you want to use it inside an abstraction. This is for advanced users and the trick is to use it in conjunction with [savestate] and here's the mechanism I use for the MERDA modules., f 45;
#X connect 0 0 5 0;
#X connect 2 0 7 0;
#X connect 2 1 3 0;
#X connect 3 0 2 0;
#X connect 4 0 5 0;
#X connect 5 1 6 0;
#X connect 6 0 3 1;
#X connect 7 0 4 0;
#X restore 415 299 pd abstraction-mode;
#X text 303 212 Whenever the abstraction learns something new \, you'll be prompted to save your patch when you close it \, so it'll remember when you reopen it., f 38;
#X connect 20 0 33 0;
#X connect 23 0 33 0;
#X connect 25 0 33 0;
#X connect 33 0 41 0;
#X connect 33 1 24 0;
#X connect 43 0 33 0;
