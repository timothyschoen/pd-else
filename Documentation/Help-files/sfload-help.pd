#N canvas 520 74 564 521 10;
#X obj 306 5 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#X obj 345 12 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 23 41 cnv 4 4 4 empty empty Load\ sounf\ files\ into\ arrays 0 28 2 18 #e0e0e0 #000000 0;
#X obj 458 12 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 478 12 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 515 12 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 464 27 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 502 27 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 305 4 graph;
#X obj 3 4 cnv 15 301 42 empty empty sfload 20 20 2 37 #e0e0e0 #000000 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 2 4 graph;
#X obj 7 484 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 7 301 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 7 376 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 7 444 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 95 308 cnv 17 3 62 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X msg 32 172 load bubul.mp3;
#X obj 32 147 loadbang;
#X obj 196 153 cnv 16 245 90 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-file 534167 float 2;
#X coords 0 1 534167 -1 247 92 1 0 0;
#X restore 195 152 graph;
#X text 176 308 set <symbol> - set array name, f 61;
#X text 191 457 1) symbol - array name (default: none);
#X listbox 32 228 18 0 0 0 - - - 0;
#X obj 95 384 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 145 228 info;
#X text 224 385 list - <size \, sample rate \, channels \, bits>, f 43;
#X text 22 270 see also:;
#X obj 161 270 else/play.file~;
#X obj 448 270 else/player~;
#X obj 345 270 else/tabplayer~;
#X obj 262 270 else/sample~;
#N canvas 713 164 434 564 threaded 0;
#X msg 174 193 load bubul.mp3;
#X obj 101 424 cnv 16 245 90 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-threaded 534167 float 2;
#X coords 0 1 534167 -1 247 92 1 0 0;
#X restore 100 423 graph;
#X listbox 174 330 18 0 0 0 - - - 0;
#X text 287 330 info;
#X obj 174 303 else/sfload -t \$0-threaded;
#X obj 110 165 trigger bang bang bang;
#X obj 110 129 bng 19 250 50 0 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000;
#X obj 270 166 print a;
#X obj 174 359 print b;
#X obj 110 359 print c;
#X msg 220 269 threaded \$1;
#X obj 220 244 tgl 16 0 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000 0 1;
#X msg 189 220 0;
#X msg 220 220 1;
#X text 75 23 By default [sfload] works in threaded mode \, which guarantees order of execution. If you wanna load large files and would like to not choke Pd's audio you can try loading files in threaded mode \, but this ruins order of execution (and you can use the output of [sfload] to know when it is done loading)., f 49;
#X connect 0 0 5 0;
#X connect 3 0 9 0;
#X connect 5 0 3 0;
#X connect 6 0 10 0;
#X connect 6 1 0 0;
#X connect 6 2 8 0;
#X connect 7 0 6 0;
#X connect 11 0 5 0;
#X connect 12 0 11 0;
#X connect 13 0 12 0;
#X connect 14 0 12 0;
#X restore 470 217 pd threaded;
#X obj 7 408 cnv 3 550 3 empty empty flags 8 12 0 13 #dcdcdc #000000 0;
#X text 210 421 -t: sets to threaded mode;
#X obj 32 201 else/sfload \$0-file;
#X text 152 353 threaded <float> - non zero sets to threaded mode, f 65;
#X obj 87 270 soundfiler;
#X text 74 87 [sfload] is similar to [soundfiler] supports more file formats (officialy AAC \, AIF \, CAF \, FLAC \, MP3 \, OGG \, OPUS & WAV). It can also load into multichannel arrays and download files from web links!, f 65;
#X text 104 338 download <symbol \, float> - link to download and same optionals, f 73;
#X text 128 323 load <symbol \, float> - file to load and optional channel \, size \, start, f 69;
#N canvas 683 68 609 608 load 0;
#X obj 48 433 cnv 16 245 130 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array 0-\$0-example 11025 float 2;
#X coords 0 1 11025 -1 247 132 1 0 0;
#X restore 47 432 graph;
#X obj 314 432 cnv 16 245 130 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array 1-\$0-example 87741 float 2;
#X coords 0 1 87741 -1 247 132 1 0 0;
#X restore 313 431 graph;
#X msg 67 193 load stereo.wav;
#X obj 123 377 else/sfload \$0-example;
#X msg 98 222 load stereo.wav -1 -1 0;
#X msg 162 328 load didge.flac 1 0 500;
#X msg 123 255 load stereo.wav -1 1000 250;
#X text 252 222 same as above;
#X text 171 192 load with default values;
#X text 299 243 use file's number of channel \, resize array to 1000ms and load from file at 250ms onset, f 36;
#X text 318 324 Load channel 1 in array 1 \, with the current array size from onset 500ms, f 35;
#X text 290 288 Load channel 0 in array 0 \, with 250ms array size from onset 500ms, f 35;
#X msg 146 294 load didge.flac 0 250;
#X text 62 57 By default the "load" message loads the file with its number of channels and samples \, starting from the beggining of the file. We can optionally set the channel to load (where '-1' is all channels \, '0' is the first channel \, '1' is the second and so on). In the case of multichannel arrays \, it will also try to match the channel number from the array., f 80;
#X text 62 118 The 2nd optional argument is the array size \, where "-1" resizes to the array size \, "0" keeps the current size and values above '0' set the array size in ms., f 80;
#X text 62 148 The last optional argument is the file onset in ms (default 0)., f 80;
#X text 62 7 When loading mono or multichannel files \, [sfload] searches for multichannel arrays 0 which are preceded by "x-" (where 'x' is the channel number indexed from 0). If found \, it has loading priority \, if it fails it searches for an array with the exact given name instead., f 80;
#X connect 4 0 5 0;
#X connect 6 0 5 0;
#X connect 7 0 5 0;
#X connect 8 0 5 0;
#X connect 14 0 5 0;
#X restore 470 175 pd load;
#N canvas 713 164 584 620 +examples 0;
#X obj 57 191 cnv 16 245 130 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array 0-\$0-stereo 168131 float 2;
#X coords 0 1 168131 -1 247 132 1 0 0;
#X restore 56 190 graph;
#X obj 413 452 else/sfload \$0-stereo;
#X msg 426 425 load didge.flac 1;
#X msg 350 523 load didge.flac 1;
#X obj 350 558 else/sfload 0-\$0-stereo;
#X msg 356 226 stop;
#X obj 505 286 bng 30 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 342 286 else/out~;
#X msg 346 203 play;
#X obj 346 254 else/tabplayer~ \$0-stereo 2;
#X obj 57 342 cnv 16 245 130 empty empty empty 20 12 0 10 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array 1-\$0-stereo 168131 float 2;
#X coords 0 1 168131 -1 247 132 1 0 0;
#X restore 56 341 graph;
#X msg 48 84 download https://upload.wikimedia.org/wikipedia/en/1/10/Michael_Jackson_Thriller.ogg, f 84;
#X text 62 60 (downloading from an internet link \, this one takes a little while of course...), f 80;
#X obj 48 127 else/sfload \$0-stereo;
#X msg 413 398 load didge.flac 0;
#X text 469 513 load right channel into left, f 10;
#X text 95 31 The "download" message has the same optional arguments than 'load"., f 67;
#X msg 375 365 load stereo.wav;
#X text 346 144 You can use [tabplayer~] to play multichannel arrays., f 24;
#X text 88 534 You can force a channel swap if you set the array channel specifically., f 38;
#X connect 3 0 2 0;
#X connect 4 0 5 0;
#X connect 6 0 10 0;
#X connect 9 0 10 0;
#X connect 10 0 8 0;
#X connect 10 1 8 1;
#X connect 10 2 7 0;
#X connect 13 0 15 0;
#X connect 16 0 2 0;
#X connect 19 0 2 0;
#X restore 470 196 pd +examples;
#X connect 16 0 34 0;
#X connect 17 0 16 0;
#X connect 34 0 22 0;
